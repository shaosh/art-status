<link rel="import" href="./alert-modal.html">
<link rel="import" href="./assign-modal.html">
<link rel="import" href="./uploading-modal.html">
<link rel="import" href="./loading-modal.html">
<link rel="import" href="./msg-card.html">

<dom-module id="app-main-body">
	<style>
		#mainContainer, #msgContainer{
			padding: 20px 20px 0 20px;
      display: none;
		}
    paper-card{
      width: 100%;
      margin-bottom: 20px;
    }
    paper-card .header{
      background-color: #83A6D9;
      padding: 16px;
      font-weight: bold;
    }
    #taskOverview p, .cardItem p{
      margin: 10px 0;
    }
		.uploadPanel{
			width: 100%;
			height: 40px;
			box-sizing: border-box;
      position: relative;
		}
		.viewPanel{
			text-align: left;
		}
    .iframe-wrapper{
      text-align: center
    }    
    #commentForm{
      overflow: hidden;
    }
    #sumbitCommentButton{
      float:right;
    }
    #closeButton{
      color: #fff;
      float:right;
      background-color: var(--paper-red-500);
    }
    #showCommentButton{
      display:none;
      max-width: 200px
    }
    #reopenWrapper{
      display:none;
    }
    #reopenButton{  
      color: #fff;    
      background-color: var(--paper-blue-500);
    }
    paper-button.blue {
      color: var(--paper-light-blue-500);
      --paper-button-flat-focus-color: var(--paper-light-blue-50);
    }
    paper-button.blue:hover {
      background: var(--paper-light-blue-50);
    }
    paper-button[toggles][active].blue {
      background-color: rgba(66, 133, 244, 0.25);
    }
    paper-button.red {
      color: var(--paper-red-500);
      --paper-button-flat-focus-color: var(--paper-red-50);
    }
    paper-button.red:hover {
      background: var(--paper-red-50);
    }
    paper-button.green {
      color: var(--paper-green-500);
      --paper-button-flat-focus-color: var(--paper-green-50);
    }
    paper-button.green:hover {
      background: var(--paper-green-50);
    }
    .cardVersion span.green, .cardVersion span.red, .cardVersion span.orange{
       border-radius:5px;
       padding:2px;
       margin-left:5px;
       color: white;
    }
    .cardVersion span.green{
      background:var(--paper-green-500);
    }
    .cardVersion span.red{
      background:var(--paper-red-500);
    }
    .cardVersion span.orange{
      background:var(--paper-amber-500);
    }
    #proofCheckbox{
      margin-bottom:20px;
      display:block;
    }
    paper-checkbox.blue {
      --paper-checkbox-checked-color: var(--paper-light-blue-500);
      --paper-checkbox-checked-ink-color: var(--paper-light-blue-500);
      --paper-checkbox-unchecked-color: var(--paper-light-blue-900);
      --paper-checkbox-unchecked-ink-color: var(--paper-light-blue-900);
    }
    #change-modal, #upload-modal, #manual-modal{
      min-height: 300px;
      min-width: 400px;
    }
    #manual-modal p{
      margin-top:30px;
      margin-bottom: 5px;
    }
    #manual-modal input{
      margin-top: 5px;
    }
    iframe{
    	width: 480px; 
    	height: 270px; 
    	border-radius: 5px; 
    	border: 1px solid #d9d9d9;
      margin: 10px auto;
    }
    #toast{
      position:absolute;
      width: 300px;
      left: 50%;
      margin-left: -150px;
      text-align: center;
      background: #4285f4;
    }
    div.buttons{
      margin-top: 20px;
    }
    p#manualModalErrMsg{
      color: red;
      display:none;
      margin-top: 5px!important;
    }
    #job-desc{
      margin-top:-29px;
      margin-left:100px;
    }
	</style>
	<template>
		<div id="mainContainer">
      <paper-card>
        <div class="card-content" style="text-align:left">
          <paper-button tabindex="0" id="showCommentButton" noink on-click="showCommentBox">Add a comment</paper-button>
          <div id="commentForm" style="display:none">
            <paper-textarea id="commentInput" label="Enter your comment" value="{{commentText}}"></paper-textarea>
            <paper-button tabindex="0" id="sumbitCommentButton" class="blue" disabled noink on-click="submitComment">Submit Comment</paper-button>
            <paper-button tabindex="0" id="closeButton" raised on-click="closeJob">Close</paper-button>
          </div>
          <div id="reopenWrapper">
            <p>This job has already been closed. Click the button to reopen it</p>
            <paper-button tabindex="0" id="reopenButton" noink on-click="reopenJob">Reopen</paper-button>
          </div>  
        </div>            
      </paper-card>
      <paper-card id="taskOverview" >
        <div class="header">
          Task Overview
        </div>
        <div class="card-content" style="padding-bottom:30px">
          <p>Design Name: <span>{{jobname}}</span></p>
          <p>Primary Assignee: <span>{{username}}</span></p>          
          <p>Task Status: <span>{{status}}</span></p>       
          <p>Task Details: <div id="job-desc"></div></p>           
        </div>
      </paper-card>
			<div class="viewPanel"> 
        <template is="dom-repeat" items="{{cards}}" sort="sortCard">
          <paper-card class="cardItem" >
            <div class="header">
              <span>{{item.title}}</span>              
            </div>
            <div class="card-content">
              <p>{{item.time}}</p>
              <p>{{item.text}}</p>
              <p style$="{{item.feedbackDisplay}}">Customer Review:&nbsp;<span>{{item.feedback}}</span></p>
              <template is="dom-if" if="{{isPdf(item.documentId)}}">
                <div class="cardVersion">Version: #<span class="verSpan">{{item.version}}</span>
                  <span class$="{{item.badgeClass}}" style$="{{item.badgeDisplay}}">{{item.badgeText}}</span>
                </div>
                <div class="iframe-wrapper">
                  <iframe src="{{item.viewurl}}" allowfullscreen="allowfullscreen"></iframe>
                </div>
              </template>
            </div>
            <div class="card-actions" style$="{{item.display}}">
              <paper-textarea class="cardComment" label="Enter your comment" value="{{item.pdfComment}}" style$="{{item.commentInputDisplay}}"></paper-textarea>
              <paper-textarea class="customerComment" label="Enter customer's feedback" value="{{item.feedbackInput}}" style$="{{item.feedbackInputDisplay}}"></paper-textarea>
              <paper-button class="green feedbackButton" on-click="receiveFeedback" disabled?="{{item.feedbackDisabled}}" style$="{{item.feedbackButtonDisplay}}">{{item.feedbackStatus}}</paper-button>
              <paper-button class="green approveButton" on-click="reviewArt" data-version="{{item.version}}" disabled?="{{item.disabled}}" style$="{{item.reviewButtonDisplay}}">Approve</paper-button>
              <paper-button class="red rejectButton" on-click="reviewArt" data-version="{{item.version}}" disabled?="{{item.disabled}}" style$="{{item.reviewButtonDisplay}}">Request Change</paper-button>
            </div>
          </paper-card>
        </template>				 
			</div>
      <paper-toast id="toast" text="{{toastText}}"></paper-toast>
		</div>
    <div id="msgContainer">
      <template  id="msgRepeat" is="dom-repeat" items="{{colleagues}}">
        <msg-card colleague="{{item}}"></msg-card>
      </template>
    </div>
    <alert-modal text="{{alertText}}"></alert-modal>
    <assign-modal users="{{users}}" job="{{job}}" assigneeid="{{assigneeid}}" jobs="{{jobs}}" username="{{username}}"></assign-modal>
    <uploading-modal></uploading-modal>
    <loading-modal></loading-modal>
    <paper-dialog id="change-modal" modal>
      <h2>Changes Detected</h2>
      <p>
        Changes has been detected in file <span>{{changedFile}}</span>. Do you want to commit this change to the repo?
      </p>  
      <p>You also need to upload the PDF file for this change. Click the button below to select the PDF file.</p> 
      <input type="file" id="changeModalInput">   
      <div class="buttons">
        <paper-button dialog-confirm autofocus on-click="uploadChange" disabled id="changeCommitButton">Yes, commit.</paper-button>
        <paper-button dialog-dismiss autofocus>No, don't commit.</paper-button>
      </div>
    </paper-dialog>	
    <paper-dialog id="upload-modal" modal>
      <h2>Upload Proof</h2>
      <p>
        Select a PDF file to upload
      </p>   
      <input type="file" id="uploadModalInput"><br>
      <div class="buttons">
        <paper-button dialog-confirm autofocus id="proofUploadButton" disabled>Yes, upload.</paper-button>
        <paper-button dialog-dismiss autofocus>No, don't upload.</paper-button>
      </div>
    </paper-dialog> 
    <paper-dialog id="manual-modal" modal>
      <h2>Upload Art Revision</h2>
      <p>
        Select a CDR file to upload
      </p>   
      <input type="file" id="manualModalCdrInput"><br>
      <p id="manualModalErrMsg">The CDR file has to be "<6-Digit-Order-Number-Of-Current-Job>.cdr"</p>
      <p>
        Select a PDF file to upload
      </p>   
      <input type="file" id="manualModalPdfInput"><br>
      <div class="buttons">
        <paper-button dialog-confirm autofocus id="manualUploadButton" disabled>Yes, upload.</paper-button>
        <paper-button dialog-dismiss autofocus>No, don't upload.</paper-button>
      </div>
    </paper-dialog> 	
	</template>
	<script>
    var boxViewLib = require('./node_modules/node-box-view'),
        isValid = require('./node_modules/is-valid-path'),
        fileExists = require('./node_modules/file-exists'),
        pathExists = require('./node_modules/path-exists');

    var myKey = '9ucmktt493ndyfnp9lvpwmsfky8dmtc7',
        boxView = new boxViewLib(myKey), 
        docUrl = 'https://view-api.box.com/1/documents/',
        PDF = 'pdf',
        DEFAULTPATH = '/artapp/temp/';

		Polymer({
      is: 'app-main-body',
      properties: {
        job: {
          type: Object,
          value: null,
          notify: true,
          observer: 'jobObserver'
        },
        jobs: {
          type: Array,
          notify: true
        },
        jobid: {
          type: String,
          notify: true
        },
        jobname: {
          type: String,
          notify: true
        },
        time: {
          type: String,
          notify: true
        },
        status: {
          type: String,
          notify: true
        },
        description:{
          type: String,
          notify: true
        },
        username: {
          type: String,
          notify: true
        },
        assigneeid: {
          type: String,
          notify: true
        },
        updater: {
          type: String,
          notify: true
        },
        jobTitle: {
          type: String,
          notify: true
        },
        statusTitle: {
          type: String,
          notify: true
        },
        imagenum: {
        	type: Number,
        	notify: true
        },
        imageurl: {
        	type: String,
        	notify: true
        },
        versions: {
        	type: Array,
        	notify: true,
          value:[]
        },
        cards: {
          type: Array,
          notify: true,
          value: []
        },
        users: {
          type: Array, 
          notify: true,
          value: []
        },
        viewurl: {
          type: String,
          notify: true
        },
        toastText: {
          type: String,
          notify: true
        },
        imageurlErrMsg: {
          type: String,
          notify: true
        },
        validImageurl: {
          type: Boolean,
          notify: true,
          value: false
        }, 
        changedFile: {
          type: String,
          notify: true
        },
        tab: {
          type: String,
          notify: true,
          observer: 'tabObserver'
        },
        commentText: {
          type: String,
          notify: true,
          observer: 'commentTextObserver'
        }, 
        getCardsRunning: {
          type: Boolean,
          notify: true,
          value: false
        },
        alertText: {
          type: String,
          notify: true,
          value: ''
        },
        viewers: {
          type: Array,
          notify: true,
          value: []
        },
        alljobs:{
          type: Array, 
          notify: true
        },
        minejobs:{
          type: Array, 
          notify: true
        },
        colleagues: {
          type: Array, 
          notify: true,
          value: [
            {
              name: 'Jessie',
              title: 'Customer Service',
              online: 'true',
              id: '0'
            },
            {
              name: 'Matt',
              title: 'Production Manager',
              online: 'false',
              id: '1'
            },
            {
              name: 'Sarah',
              title: 'COO',
              online: 'true',
              id: '2'
            },
            {
              name: 'John',
              title: 'Boss',
              online: 'false',
              id: '3'
            },
            {
              name: 'Karisa',
              title: 'Designer',
              online: 'true',
              id: '4'
            }
          ]
        }
      },  
      openChangeModal: function(filepath){
        var dialog = document.getElementById('change-modal');
        if (dialog) {
          dialog.open();
        }
      },      
      jobObserver: function(newValue, oldValue){
        var that = this;
        if(!!newValue){
          if(!oldValue || newValue.jobId !== oldValue.jobId){
            this.jobid = newValue.jobId;
            this.getCards();
          }          

          var interval = 60000;
          if(!this.getCardsRunning){
            setIntervalByTimeout(
              function(){that.getCards()}, interval
            );
            this.getCardsRunning = true;
          }
        }
      },
      setJobData: function(obj){
        var that = this;
        if(!!obj){
          this.job.jobname = this.jobname = obj.name.replace(/^request : /i, '');
          this.job.updatedAt = this.time = obj.updatedAt;
          this.job.assigneeId = this.assigneeid = obj.assigneeId;
          this.job.username = this.username = obj.username;
          this.job.description = this.description = obj.description;          
          this.job.status = this.status = obj.status;
          this.job = JSON.parse(JSON.stringify(this.job));
          var desc = obj.description.replace(/@@/g, '<br>');
          document.getElementById('job-desc').innerHTML = desc;  
          this.updateJobViewPanel(this.job);
        }
      },
      updateJobViewPanel: function(newjob){
        var temp = [];
        var tempall = [];
        var tempmine = [];
        this.jobs.forEach(function(job){
          if(job.jobId === newjob.jobId){
            job = newjob;
          }
          temp.push(job);
        });        
        this.jobs = temp;
        
        this.alljobs.forEach(function(job){
          if(job.jobId === newjob.jobId){
            job = newjob;
          }
          tempall.push(job);
        });
        this.alljobs = tempall;

        this.minejobs.forEach(function(job){
          if(job.jobId === newjob.jobId){
            job = newjob;
          }
          tempmine.push(job);
        });
        this.minejobs = tempmine;
      },
      getCards: function(){
        var options = {
          url: CARD_URL.replace('{jobId}', this.jobid),
          headers: HEADER,
          method: 'PUT',
          json: true,
          body: {  
            'userId': localStorage.userId
          }
        },
          that = this;
        request(options, function(error, response, body){
          var obj = body;
          console.log('getCards body', body)
          if(!error && response.statusCode === 200){
            if(!!obj && !!obj.cards && obj.cards.length > 0 && obj.cards.length !== that.cards.length){             
              that.setJobData(obj);
              if(dict[that.status.toLowerCase()] === STATUSES.DONE){
                that.$.showCommentButton.style.display = 'none';
                that.$.commentForm.style.display = 'none';
                that.$.reopenWrapper.style.display = 'block';
                that.$.reopenButton.removeAttribute('disabled');
              }
              else{
                that.$.showCommentButton.style.display = 'block';
                that.$.reopenWrapper.style.display = 'none';
                that.$.commentForm.style.display = 'none';
              }
              that.processCards(obj.cards);
            }
            else if(!!obj && !!obj.cards && obj.cards.length === 0){
              that.setJobData(obj);
              that.cards = [];
              that.domHost.removeLoading();
              if(dict[that.status.toLowerCase()] === STATUSES.DONE){
                that.$.showCommentButton.style.display = 'none';
                that.$.commentForm.style.display = 'none';
                that.$.reopenWrapper.style.display = 'block';
                that.$.reopenButton.removeAttribute('disabled');
              }
              else{
                that.$.showCommentButton.style.display = 'block';
                that.$.reopenWrapper.style.display = 'none';
                that.$.commentForm.style.display = 'none';
              }
            }
            else{
              that.domHost.removeLoading();
            }
            if((that.viewers.length !== obj.viewers.length) || _.difference(that.viewers, obj.viewers).length > 0){
              that.setViewers(obj.viewers);
            }             
          }
          else{
            that.domHost.removeLoading();
            outputError('GetCards Error: ' + !!error ?  error : response.statusCode);
          }
        });
      },
      getCurrJob: function(){
        var that = this,
            defer = Q.defer();
        var options = {
          url: CARD_URL.replace('{jobId}', this.jobid),
          headers: HEADER,
          method: 'PUT',
          json: true,
          body: {  
            'userId': localStorage.userId
          }
        };
        request(options, function(error, response, body){
          if(!error && response.statusCode === 200){
            defer.resolve(body);
          }
          else{
            outputError('GetCurrJob Error: ' + !!error ?  error : response.statusCode);
            defer.reject('GetCurrJob Error: ' + !!error ?  error : response.statusCode);
          }
        });
        return defer.promise;
      },
      getLock: function(){
        var that = this,
            defer = Q.defer();
        var options = {
          url: LOCK_URL.replace('{jobId}', this.jobid),
          headers: HEADER,
          json: true 
        };
        request(options, function(error, response, body){
          if(!error && response.statusCode === 200){
            defer.resolve(body);
          }
          else{
            outputError('GetLock Error: ' + !!error ?  error : response.statusCode);
            defer.reject('GetLock Error: ' + !!error ?  error : response.statusCode)
          }
        });
        return defer.promise;
      },
      showCommentBox: function(){
        this.$.showCommentButton.style.display = 'none';
        this.$.commentForm.style.display = 'block';
      },
      commentTextObserver: function(newValue, oldValue){
        if((!oldValue || !oldValue.trim()) && (!!newValue && !!newValue.trim())){
          this.$.sumbitCommentButton.removeAttribute('disabled');
        }
        else if(!newValue || !newValue.trim()){
          this.$.sumbitCommentButton.setAttribute('disabled', true);
        }
      },
      submitComment: function(e){
        var that = this;
        this.$.sumbitCommentButton.setAttribute('disabled', true);
        if(!this.commentText){
          return;
        }
        this.getCurrJob().then(
          function(job){
            if(job.status.toLowerCase() !== STATUSESTEXT.DONE){
              that.addCard(STEPS.COMMENT, that.commentText, '', null, dict[that.status.toLowerCase()], '', null, '');  
              that.commentText = '';
             
            }
            else{
              
              that.showAlert('This job has already been closed.');
            }
          }, 
          function(e){
            outputError(e); 
            that.commentText = '';
          }
        );        
      },
      closeJob: function(){ 
        var that = this;
        this.getCurrJob().then(
          function(job){            
            if(job.status.toLowerCase() === STATUSESTEXT.WORKING){
              that.addCloseCard();
            }
            else if(job.status.toLowerCase() === STATUSESTEXT.LOCKED){
              that.showAlert('This job has been locked by ' + that.getUserName(job.lockerId) + '. It needs to be unlocked before closing.');
            }
            else{
              that.showAlert('This job has already been closed.');
            }
          }, 
          function(e){outputError(e)}
        );
      },
      addCloseCard: function(){
        this.addCard(STEPS.DONE, this.commentText, '', null, STATUSES.DONE, '', null, '');  
        this.commentText = ''; 
      },
      reopenJob: function(){
        var that = this;
        this.$.reopenButton.setAttribute('disabled', true);
        this.getCurrJob().then(
          function(job){
            if(job.status.toLowerCase() === STATUSESTEXT.DONE){
              that.addReopenCard();
            }
            else{
              that.showAlert('This job has already been opened.');
            }
          }, 
          function(e){outputError(e)}
        );
      },
      addReopenCard: function(){
        this.addCard(STEPS.REOPENED, this.commentText, '', null, STATUSES.WORKING, '', null, '');  
        this.commentText = ''; 
      },
      reviewArt: function(e){
        var that = this,
            stepid = e.model.item.stepId === STEPS.ARTREVISION ? STEPS.ARTREVISION : STEPS.CUSTOMERREVIEWRECEIVED,
            nextStepid = e.model.item.stepId === STEPS.ARTREVISION ? STEPS.REVIEW : STEPS.PROOFREVIEW,
            isApprove = Polymer.dom(e).localTarget.className.indexOf('approveButton') > -1,
            feedback = e.model.item.stepId === STEPS.ARTREVISION ? '' : e.model.item.feedbackInput;
        var button = Polymer.dom(e).localTarget;
        button.setAttribute('disabled', true);
        button.parentElement.style.display = 'none';
        this.getCurrJob().then(
          function(job){
            button.removeAttribute('disabled');
            if(job.status.toLowerCase() === STATUSESTEXT.WORKING){
              var isLast = that.isLastNonComment(stepid, e.model.item.index, job.cards);
              if(!!isLast){
                if(!!isApprove){
                  that.addApproveCard(nextStepid, e.model.item.version, e.model.item.pdfComment, feedback);
                }
                else{
                  that.addRejectCard(nextStepid, e.model.item.version, e.model.item.pdfComment, feedback);
                }                
              }
              else{
                var reviewId = stepid === STEPS.ARTREVISION ? STEPS.REVIEW : STEPS.PROOFREVIEW;
                var item = that.getNextNonComment(reviewId, e.model.item.index, job.cards);
                if(item === null){
                  that.showAlert('This art revision/proof has already been reviewed.');
                }
                else{
                  var text = item.approve === REVIEW.REJECT ? 'rejected' : 'approved';
                  that.showAlert('This art revision/proof has already been ' + text + ' by ' + item.username);
                }                
              }              
            }
            else if(job.status.toLowerCase() === STATUSESTEXT.DONE){
              that.showAlert('This job has already been closed.');
            }
            else{
              var username = that.getUserName(job.lockerId);
              var text = '';
              if(!!username){
                text = username + ' is revising it.';
              }
              that.showAlert('This job is locked. ' + text);
            }
          }, 
          function(e){outputError(e)}
        );
      },
      addApproveCard: function(stepid, version, pdfComment, feedback){
        this.addCard(stepid, pdfComment, '', REVIEW.APPROVENUM, STATUSES.WORKING, version, null, feedback);  
        this.commentText = '';
      },
      addRejectCard: function(stepid, version, pdfComment, feedback){
        this.addCard(stepid, pdfComment, '', REVIEW.REJECTNUM, STATUSES.WORKING, version, null, feedback);  
        this.commentText = '';
      },
      addStartArtRevisionCard: function(){
        var text = localStorage.username + ' starts revising this job. It locks this job.';
        this.addCard(STEPS.COMMENT, text, '', null, STATUSES.LOCKED, '', null, '');
      },
      addCard: function(step, comment, documentId, approve, status, version, pending, feedback){
        var that = this,
            ver = '';
        if(!!version){
          ver = '$$$' + version;
        }
        var options = {
          url: CARD_URL.replace('{jobId}', this.job.jobId),
          headers: HEADER,
          method: 'POST',
          json: true,
          body: {            
            "card":{
              "updaterId": localStorage.userId,
              "step": step,
              "comment": comment + ver,
              "documentId": documentId,
              "approve": approve,
              'viewurl': '',
              'pending': pending,
              'feedback': feedback
            },
            "job": {
               "status": status, 
               "assigneeId": this.assigneeid
            }
          }
        };   

        request(options, function(error, response, body){
          console.log('body', body, response);
          if(!error && response.statusCode === 200){
            if(!!body && !!body.cards && body.cards.length > 0){
              if(dict[body.status.toLowerCase()] === STATUSES.DONE){
                that.$.commentForm.style.display = 'none';
                that.$.reopenWrapper.style.display = 'block';   
                that.$.reopenButton.removeAttribute('disabled');            
                that.status = STATUSESTEXT.DONE;
              }
              else{
                if(that.$.reopenWrapper.style.display !== 'none'){
                  that.status = STATUSESTEXT.WORKING;
                  that.$$('.approveButton').removeAttribute('disabled');
                  that.$$('.rejectButton').removeAttribute('disabled');
                }
                that.$.showCommentButton.style.display = 'block';
                that.$.commentForm.style.display = 'none';
                that.$.reopenWrapper.style.display = 'none';
              }
              that.setJobData(body);
              that.processCards(body.cards);              
            }
          }
          else{
            outputError('AddCard Error: ' + !!error ? error : response.statusCode);
          }
        }); 
      },
      isPdf: function(documentId){
        return !!documentId;
      },
      isDone: function(){
        return dict[this.status.toLowerCase()] === STATUSES.DONE;
      },
      isOpen: function(){
        return dict[this.status.toLowerCase()] !== STATUSES.DONE;
      },
      isNonComment: function(step){
        return step !== STEPS.COMMENT;
      },
      processCards: function(list){
        var that = this,
          promiseList =[],
          resList = [];
        var count = 0;
        list.forEach(function(item, index){
          var title = item.step.toLowerCase(); 
          item.feedbackDisplay = 'display:none';
          item.feedbackInputDisplay = 'display:none'; 
          item.feedbackButtonDisplay = 'display:none';  
          item.commentInputDisplay = 'display:block';
          item.reviewButtonDisplay = 'display:inline-block';
          item.badgeDisplay = 'display:none';
          if(item.stepId === STEPS.COMMENT){
            item.text = 'From ' + item.username  + ':\n' + item.comment;
          }
          else if(item.stepId === STEPS.ARTREVISION){
            item.text = item.username + ' made a revision to the art.';            
          }
          else if(item.stepId === STEPS.REVIEW || item.stepId === STEPS.PROOFREVIEW ){
            item.text = item.username + ' marked the pending ';            
            var ver = '';                      
            if(!!item.comment && item.comment.split('$$$').length > 1){
              var splitComment = item.comment.split('$$$');
              ver = splitComment[splitComment.length - 1];
              item.comment = item.comment.substring(0, item.comment.length - ver.length - 3);
            }

            if(item.stepId === STEPS.REVIEW){
              item.text = item.text + 'revision #' + ver + ' as ';
            }
            else{
              item.text = item.text + 'proof #' + ver + ' as ';
              if(!!item.feedback){
                item.feedbackDisplay = 'display:block';
              }
              else{
                item.feedbackDisplay = 'display:none';
              }
            }
            if(!!item.approve){
              item.text = item.text + 'approved';
            }
            else {
              item.text = item.text + 'rejected';
            }
            if(!!item.comment){
              item.text = item.text + ': ' + item.comment;
            }    
            else{
              item.text = item.text + '.';
            }      
          }
          else if(item.stepId === STEPS.PROOF){
            item.text = item.username + ' uploaded a proof.';
            item.feedbackInputDisplay = item.commentInputDisplay = item.reviewButtonDisplay = 'display:none'; 
            item.feedbackButtonDisplay = 'display:inline-block'; 
            item.feedbackStatus = item.step + '...';
            item.feedbackDisabled = 'false';    
            // item.disabled = 'true';        
          }
          else if(item.stepId === STEPS.CUSTOMERREVIEWRECEIVED){
            item.text = item.username + ' uploaded a proof.';
            item.feedbackInputDisplay = 'display:block'; 
            item.feedbackButtonDisplay = 'display:none'; 
            item.feedbackStatus = item.step;
            item.feedbackDisabled = 'true';
            item.commentInputDisplay = 'display:block';
            item.reviewButtonDisplay = 'display:inline-block';
            // item.disabled = 'false';      
          }
          else if(item.stepId === STEPS.DONE){
            item.text = item.username + ' closed this issue' 
            if(!!item.comment && item.comment !== 'undefined'){
              item.text = item.text + ': ' + item.comment;
            }
            else{
              item.text = item.text + '.';
            }
          }
          else if(item.stepId === STEPS.REQUEST){
            item.text = item.username + ' sent a request to ' + item.comment + '.';
          }
          else if(item.stepId === STEPS.REOPENED){
            item.text = item.username + ' reopened this issue.';
          }
          item.time = moment(item.updatedAt).format("MMM DD, YYYY, h:mm:ss a");
          item.title = item.step;
          item.index = index;
          item.pdfComment = '';
          item.display = 'display:none';
          if(that.status.toLowerCase() === STATUSESTEXT.DONE || that.status.toLowerCase() === STATUSESTEXT.LOCKED || item.feedbackDisabled === 'false'){
            item.disabled = 'true';
          }
          else if(that.status.toLowerCase() === STATUSESTEXT.WORKING){
            item.disabled = 'false';
          }

          if(!!item.documentId){
            count++;
            item.version = count;
            promiseList.push(that._getSession(item.documentId, item));
          }          
        });        
        Q.allSettled(promiseList).then(function(responses){
          responses.forEach(function(res){
            if(res.state === 'fulfilled' && res.value !== null){
              list[res.value.index] = res.value;
            }
            else{
              console.log('No version retrieved.');
            }
          });          
        }).done(function(){
          if(list.length > 0){
            that.turnOnCardAction(list);  
            that.setReviewBadge(list);            
            that.cards = list;    
          } 
          that.domHost.removeLoading();
        });       
      },
      toggleLockJob: function(lock){
        var appBtns = document.getElementsByClassName('approveButton'),
            rejBtns = document.getElementsByClassName('rejectButton'),
            cardCmts = document.getElementsByClassName('cardComment');
        if(lock === LOCK.LOCK){
          for(var i = 0; i < appBtns.length; i++){
            appBtns[i].setAttribute('disabled', true);
            rejBtns[i].setAttribute('disabled', true);
            cardCmts[i].setAttribute('disabled', true);            
          }
        }
        else{
          for(var i = 0; i < appBtns.length; i++){
            appBtns[i].removeAttribute('disabled');
            rejBtns[i].removeAttribute('disabled');
            cardCmts[i].removeAttribute('disabled');
          }
        }        
      },
      turnOnCardAction: function(list){
        var proofReviewIndex = this.getLastCardOfStep(STEPS.PROOFREVIEW, list);
        var proofIndex = Math.max(this.getLastCardOfStep(STEPS.PROOF, list), this.getLastCardOfStep(STEPS.CUSTOMERREVIEWRECEIVED, list));
        if(proofIndex > proofReviewIndex){
          list[proofIndex].display = 'display:block';
          return;
        }
        else if(proofReviewIndex >= 0){
          return;
        }
        var reviewIndex = this.getLastCardOfStep(STEPS.REVIEW, list);
        var artrevisionIndex = this.getLastCardOfStep(STEPS.ARTREVISION, list);
        if(artrevisionIndex > reviewIndex){
          list[artrevisionIndex].display = 'display:block';
        }
      },
      setReviewBadge: function(list){
        if(!list){
          return;
        }
        var that = this;
        list.forEach(function(item){
          if(item.stepId === STEPS.ARTREVISION || item.stepId === STEPS.PROOF || item.stepId === STEPS.CUSTOMERREVIEWRECEIVED){
            item.badgeDisplay = 'display:inline-block';
            var reviewCard = {};
            if(item.stepId === STEPS.ARTREVISION){
              reviewCard = that.getNextNonComment(STEPS.REVIEW, item.index, list);
            }
            else{
              reviewCard = that.getNextNonComment(STEPS.PROOFREVIEW, item.index, list);
            }
            if(reviewCard === null){
              item.badgeText = REVIEW.REVIEWPENDINGTEXT;
              item.badgeClass = 'orange';
            }
            else if(reviewCard.approve === REVIEW.APPROVE){
              item.badgeText = REVIEW.APPROVETEXT;
              item.badgeClass = 'green';
            }
            else{
              item.badgeText = REVIEW.REJECTTEXT;
              item.badgeClass = 'red';
            }
          }
        });
      },
      verifyRequiredPathFile: function(){
        return (!!localStorage.coreldrawPath && !!localStorage.targetFolderPath && !!localStorage.sourceFolderPath && !!localStorage.cdrappName && !!pathExists.sync(localStorage.coreldrawPath) && !!pathExists.sync(localStorage.targetFolderPath) && !!pathExists.sync(localStorage.sourceFolderPath) && !!fileExists(localStorage.cdrappName));
      },
      tabObserver: function(newValue, oldValue){
        var that = this;
        if(newValue === TABS.WATCH){
          if(!!this.verifyRequiredPathFile()){
            var jobid = this.job.name.substring(0, 6),
                sourceFile = localStorage.sourceFolderPath + SLASH + jobid + '.cdr',
                targetFile = localStorage.targetFolderPath + SLASH + jobid + '.cdr';

            if(!fileExists(sourceFile)){
              that.showAlert(jobid + '.cdr does not exist in ' + localStorage.sourceFolderPath);
              return;
            }
            this.startCopyFlow(sourceFile, targetFile);
          }
          else{
            this.showToast('Path to CorelDraw, source folder, target folder or CorelDraw name may be wrong.');
            document.getElementById('setting-modal').open();
          }
        }
        else if(newValue === TABS.ASSIGN){
          document.getElementById('assign-modal').open();
        }
        else if(newValue === TABS.MANUAL){
          this.domHost.loading();
          this.startManualUploadFlow();
        }
        else if(newValue === TABS.UPLOADPROOF){
          this.domHost.loading();
          this.startUploadProofFlow();
        }

        if(newValue === TABS.MESSAGE){
          this.showMsgContainer();
        }       
        else{
          this.showMainContainer();
        }
      },
      enableUploadButton: function(input, buttonId){
        var that = this;
        if(!!input.value && input.value.substr(-4).toLowerCase() === '.pdf'){
          var button = document.getElementById(buttonId);
          button.removeAttribute('disabled');
          if(that.tab === TABS.UPLOADPROOF){
            button.onclick = function(){
              var step = STEPS.PROOF;
              that.uploadFile(input.value, step);
              button.setAttribute('disabled', true);
              input.value = '';
            }       
          }    
        }        
        else{
          document.getElementById(buttonId).setAttribute('disabled', true);
        }
      },
      enableManualUploadButton: function(inputCdr, inputPdf){
        var that = this,
            cdrname = inputCdr.value,
            pdfname = inputPdf.value,
            expectCdrname = this.job.name.substring(0, 6).toLowerCase() + '.cdr',
            button = document.getElementById('manualUploadButton'),
            errmsg = document.getElementById('manualModalErrMsg');
        if(!!cdrname && expectCdrname !== cdrname.substr(-10).toLowerCase()){
          errmsg.style.display = 'block';
          button.setAttribute('disabled', true);
        }
        else{
          errmsg.style.display = 'none';
        }

        if(!!cdrname && expectCdrname === cdrname.substr(-10).toLowerCase() && !!pdfname && pdfname.substr(-4).toLowerCase() === '.pdf'){
          button.removeAttribute('disabled');
          errmsg.style.display = 'none';
          button.onclick = function(){
            that.manualUpload(inputCdr, inputPdf, button);
          };
        }
        else{
          button.setAttribute('disabled', true);
        }
      },
      startManualUploadFlow: function(){
        var that = this;
        this.getCurrJob().then(
          function(job){
            that.domHost.removeLoading();
            if(job.status.toLowerCase() === STATUSESTEXT.DONE){
              that.showAlert('This job has already been closed.');
            }
            else if(job.status.toLowerCase() === STATUSESTEXT.WORKING){
              that.showAlert('You cannot upload revision without starting any revisions. Or this job has already been approved.');
            }
            else{
              document.getElementById('manual-modal').open();
              var inputCdr = document.getElementById('manualModalCdrInput');
              var inputPdf = document.getElementById('manualModalPdfInput');
              var button = document.getElementById('manualUploadButton');
              var errmsg = document.getElementById('manualModalErrMsg');
              inputCdr.value = '';
              inputPdf.value = '';
              errmsg.style.display = 'none';
              button.setAttribute('disabled', true);
              inputCdr.onchange = function(){
                that.enableManualUploadButton(inputCdr, inputPdf);
              };
              inputPdf.onchange = function(){
                that.enableManualUploadButton(inputCdr, inputPdf);
              };
            }
          },
          function(e){
            that.domHost.removeLoading();
            outputError(e)
          }
        );
      },
      startUploadProofFlow: function(){
        var that = this;
        this.getCurrJob().then(
          function(job){
            that.domHost.removeLoading();
            if(job.status.toLowerCase() === STATUSESTEXT.DONE){
              that.showAlert('This job has already been closed.');
            }
            else if(job.status.toLowerCase() === STATUSESTEXT.LOCKED){
              var username = that.getUserName(job.lockerId);
              var text = '';
              if(!!username){
                text = username + ' is revising it.';
              }
              that.showAlert('This job is locked. ' + text);
            }
            else{
              var item = that.getLastNonComment(job.cards);
              if(!item){                
                that.showAlert('This job is not ready for proof. You cannot upload a proof until a revision gets approved.');
              }    
              else if((item.stepId === STEPS.REVIEW && item.approve === REVIEW.APPROVE) ||
                (item.stepId === STEPS.PROOFREVIEW && item.approve === REVIEW.REJECT)){
                document.getElementById('upload-modal').open();
                var input = document.getElementById('uploadModalInput');
                input.onchange = function(){
                  that.enableUploadButton(input, 'proofUploadButton');
                };
              }
              else if(item.stepId === STEPS.PROOFREVIEW || item.approve === REVIEW.APPROVE){
                that.showAlert('A proof has already been approved. You do not need to upload another proof.');
              }
              else if(item.stepId === STEPS.PROOF || item.stepId === STEPS.CUSTOMERREVIEWRECEIVED){
                that.showAlert('A proof has been submitted by ' + item.username + '. You are not allowed to submit a new proof before the previous one gets reviewed.');
              }
              else {
                that.showAlert('This job is not ready for proof. You cannot upload a proof until a revision gets approved.');
              }
            }
          },
          function(e){
            that.domHost.removeLoading();
            outputError(e)
          }
        )
      },
      startCopyFlow: function(sourceFile, targetFile){
        var that = this;
        this.getCurrJob().then(
          function(job){
            if(job.status.toLowerCase() === STATUSESTEXT.DONE){
              that.showAlert('This job has already been closed.');
            }
            else if(job.status.toLowerCase() === STATUSESTEXT.LOCKED){
              var username = that.getUserName(job.lockerId);
              var text = '';
              if(!!username){
                text = username + ' is revising it.';
              }
              that.showAlert('This job is locked. ' + text);
            }
            else{
              var item = that.getLastNonComment(job.cards);
              if(item === null || (item !== null && item.stepId === STEPS.REVIEW && item.approve === REVIEW.REJECT)){
                that.showToast('Start copying CDR file to local.');
                that.toggleLock(LOCK.LOCK);
                return that.copy(sourceFile, targetFile);
              }
              else if(item.stepId === STEPS.REVIEW && item.approve === REVIEW.APPROVE){
                that.showAlert('This job has already been approved by ' + item.username + '. No more art revision is allowed.');
              }
              else if(item.stepId === STEPS.PROOF || item.stepId === STEPS.CUSTOMERREVIEWRECEIVED || item.stepId === STEPS.PROOFREVIEW){
                that.showAlert('This job has already entered proof phase. No more art revision is allowed.');
              }
              else if(item.stepId === STEPS.ARTREVISION){
                that.showAlert('The art revision submitted by ' + item.username + ' is pending review. You are not allowed to start a new revision before the previous one gets reviewed.');
              }                  
            }
            throw new Error('Improper status to start copy. Abort promise chain');
            return null;
          }, 
          function(e){outputError(e)}
        ).then(
          function(res){
            if(!res){
              throw new Error('Improper status to start copy. Abort promise chain');
              return null;
            }
            that.addStartArtRevisionCard();
            return that.openInCDR(res)
          },
          function(e){outputError(e)}
        ).then(
          function(res){
            if(!res){return;}
            that.watch(res);
          },
          function(e){outputError(e)}
        );
      },
      copy: function(src, dst){
        var that = this,
            defer = Q.defer();
        fsextra.copy(src, dst, function(err){
          if(!!err){
            defer.reject('Fail to copy file: ' + err);
            return;
          }
          defer.resolve(dst);
        });
        return defer.promise;
      },
      openInCDR: function(dst){
        var cdrapp = '"' + localStorage.cdrappName + '"',
            defer = Q.defer();
        console.log('opening...');
        cmd.exec(cdrapp + ' ' + '"' + dst + '"', function(error, stdout, stderr){
          if (!!error) {
            error = 'Unable to open the file in CorelDraw: ' + error;
            defer.reject(error);
          }       
        });
        return Q.fcall(function(){return dst});
      },
      watch: function(dst){
        var defer = Q.defer(),
            that = this;

        var watcher = chokidar.watch(dst, {
          persistent: true
        });
        this.showToast('Start watching ' + path.basename(dst));
        watcher.on('change', function(path){
          that.changedFile = path;
          that.getCurrJob().then(
            function(job){
              if(job.status.toLowerCase() === STATUSESTEXT.LOCKED){
                var item = that.getLastNonComment(job.cards);
                if(item === null || (item.stepId === STEPS.REVIEW && item.approve === REVIEW.REJECT)){
                  that.openChangeModal();
                  var input = document.getElementById('changeModalInput');
                  input.onchange = function(){
                    that.enableUploadButton(input, 'changeCommitButton');
                  };
                }           
              }
            }, 
            function(e){outputError(e)}
          )
        });
      },
      upload: function(e){
      	if(e.keyCode === 13){
      		var url = this.imageurl;
      		if(url !== '' && this.validImageurl){
      			this.uploadFile(url, STEPS.ARTREVISION);
      		}
      		else{
      			console.log('Invalid URL');
      		}      		
      	}
      },
      uploadFile: function(url, step){   
      	var now = moment().format('MMDDYYYYHHmmss'),
      			filename = this.jobid + '-' + now,
      			that = this;
      	
    		if(validurl.isUri(url)){
          this._uploading();
    			return this._uploadFromUrl(url, {fileName: filename + '.' + PDF})
            .then(              
              function(res){return that._checkStatus(res);},
              function(e){outputError(e);}                
            )
            .then(
              function(res){that._renderPdfCard(res, step, STATUSES.WORKING);},
              function(e){outputError(e);}
            );
    		}
    		else{
          this._uploading();
    			return this._uploadLocalFile(url, {fileName: filename + '.' + PDF})
            .then(
              function(res){return that._checkStatus(res);},
              function(e){outputError(e);}                
            )
            .then(
              function(res){that._renderPdfCard(res, step, STATUSES.WORKING);},
              function(e){outputError(e);}
            );
    		}
      },
      _renderPdfCard: function(docid, step, status){
        this.addCard(step, '', docid, null, status, '', null, '');
      },

      _getSession: function(id, obj){
      	var defer = Q.defer();
      	boxView.getDocumentSession(id, function(err, res){
      		if(!!err){
      			var error = 'Unable to get session: ' + err;
            deferred.reject(error);
      		}
      		else{
      			obj.viewurl = res.urls.view + '?theme=dark';
      			defer.resolve(obj);
      		}
        });	
        return defer.promise;				
      },
      _addNewSession: function(res){
        var objid = res.id,
            name = res.name,                
            basename = name.split('.')[0],
            type = name.split('.')[1],
            id = basename.split('-')[0],
            date = basename.split('-')[1],
            o = {},
            defer = Q.defer(),
            that = this;
        o.viewurl = '';
        o.filename = basename + '.' + PDF;
        o.downloadurl = docUrl + objid + '/content.pdf';
        o.date = that._parseDate(date);
        o.version = '';

        this._getSession(objid, o).then(
          function(res){
            if(!!res){              
              res.version = that.versions.length;
              that.versions.unshift(res);
              defer.resolve();
            }              
            else{
              var err = 'Retrieved empty session';
              outputError(err);
              defer.reject(err);
            }
          },
          function(e){
            outputError(e);
            defer.reject(e);
          }
        );
        return defer.promise;
      },
      _getDocument: function(id){
        var defer = Q.defer();
        boxView.getDocument(id, [], function(err, res){
          if(!!err){
            var error = 'Unable to get document: ' + err;
            deferred.reject(error);
          }
          else{
            var result = typeof res === 'string' ? JSON.parse(res) : res;
            defer.resolve(result);
          }
        });
        return defer.promise;
      },
      _checkStatus: function(obj){
        var defer = Q.defer(),
            interval = 2000,
            id = obj.id,
            that = this,
            check;
        var getStatus = function(){                    
          that._getDocument(id).then(
            function(res){
              if(res.status === 'done'){
                clearInterval(check);
                console.log('SUCCESS! File is processed!');
                that.showToast("Upload Complete");
                that._removeUploading();
                defer.resolve(res.id);                
              }
            },
            function(e){
              outputError(e);
              that.showToast('Fail to Complete Upload');
              throw new Error('Fail to Complete Upload. Abort promise chain');
              that._removeUploading();
              defer.reject(e);
            }
          );
        };
        check = setInterval(getStatus, interval);
        return defer.promise;
      },
      _parseDate: function(date){
      	var m = date.substring(0, 2),
      			d = date.substring(2, 4),
      			y = date.substring(4, 8),
      			h = date.substring(8, 10),
      			min = date.substring(10, 12),
      			s = date.substring(12, 14);
      	return m + '-' + d + '-' + y + ' ' + h + ':' + min + ':' + s;
      },
      _uploadLocalFile: function(path, option){
      	var deferred = Q.defer(),
            that = this;
      	boxView.uploadFile(path, option, function(err, res){
      		if(!!err){
            that.showToast('Fail to Complete Upload');
            throw new Error('Fail to Complete Upload. Abort promise chain');
            that._removeUploading();
    				var error = 'Unable to upload from local path: ' + err;
      			deferred.reject(error);
    			}
    			else{
    				console.log('File upload from local path complete');
            deferred.resolve(res);
    			}
      	});
      	return deferred.promise;
      },
      _uploadFromUrl: function(url, option){
      	var deferred = Q.defer();		
        var that = this;
      	boxView.uploadFromUrl(url, option, function(err, res){
    			if(!!err){
            that.showToast('Fail to Complete Upload');
            that._removeUploading();
    				var error = 'Unable to upload from url: ' + err;
      			deferred.reject(error);
    			}
    			else{
    				console.log('File upload from url complete');
            deferred.resolve(res);
    			}
    		});
    		return deferred.promise;
      },
      _validateImageurl: function(){
        var INVALIDIMAGEURL = 'Invalid URL/path or path not exist',
            result;
        if(this.imageurl === ''){
          result = true;
        }
        else if(validurl.isUri(this.imageurl)){
          result = true;
        }
        else if(!!isValid(this.imageurl)){
          if(fileExists(this.imageurl)){
            result = true;
          }
          else{
            this.imageurlErrMsg = 'Unable to find the file with this path';
            result = false;
          }
        }
        else{
          this.imageurlErrMsg = INVALIDIMAGEURL;
          result = false;
        }

        this.validImageurl = result;
        return result;
      },
      _uploading: function(){
        document.getElementById('uploading-modal').open();
      },
      _removeUploading: function(){
        document.getElementById('uploading-modal').close();
        this.imageurl = '';
      },    
      showToast: function(text){
        this.toastText = text;
        document.querySelector('#toast').show();
      },  
      uploadChange: function(){
        var jobid = this.job.name.substring(0, 6),
            src = localStorage.targetFolderPath + SLASH + jobid + '.cdr',
            dst = localStorage.sourceFolderPath + SLASH + jobid + '.cdr',
            that = this,
            input = document.getElementById('changeModalInput'),
            button = document.getElementById('changeCommitButton');

        fsextra.copy(src, dst, function(err){
          if(!!err){
            console.log('Fail to copy file from' + src + ' to ' + dst + ': ' + err);
            return;
          }
          that.showToast('Commit complete');

          that.uploadFile(input.value, STEPS.ARTREVISION).then(
            function(){that.toggleLock(LOCK.UNLOCK)},
            function(e){outputError(e)}
          ).then(
            function(){
              button.setAttribute('disabled', true);
              input.value = '';
            },
            function(e){outputError(e)}
          );          
        });
      },
      manualUpload: function(inputCdr, inputPdf, button){
        var src = inputCdr.value,
            dst = localStorage.sourceFolderPath + SLASH + this.job.name.substring(0, 6) + '.cdr',
            that = this;

        fsextra.copy(src, dst, function(err){
          if(!!err){
            console.log('Fail to copy file from' + src + ' to ' + dst + ': ' + err);
            return;
          }
          that.showToast('Commit complete');

          that.uploadFile(inputPdf.value, STEPS.ARTREVISION)
          .then(
            function(){that.toggleLock(LOCK.UNLOCK);},
            function(e){outputError(e)}
          ).then(
            function(){
              button.setAttribute('disabled', true);
              inputCdr.value = '';
              inputPdf.value = '';
            },
            function(e){outputError(e)}
          );
        });
      },
      sortCard: function(a, b){
        return moment(b.updatedAt).diff(moment(a.updatedAt));
      },
      showMainContainer: function(){
        this.$.msgContainer.style.display = 'none';
        this.$.mainContainer.style.display = 'block';
      },
      showMsgContainer: function(){
        this.$.mainContainer.style.display = 'none';
        this.$.msgContainer.style.display = 'block';
      },
      toggleLock: function(lock){
        var defer = Q.defer();
        var options = {
          url: LOCK_URL.replace('{jobId}', this.jobid),
          headers: HEADER,
          method: 'POST',
          json: true,
          body: {  
            'lock': lock,
            'lockerId': localStorage.userId
          }
        },
          that = this;
        request(options, function(error, response, body){
          if(!error && response.statusCode === 200){
            if(!!body && body.lock === true && lock === LOCK.LOCK){
              that.toggleLockJob(LOCK.LOCK);
              defer.resolve(body);
            }
            else if(!!body && body.lock === false && lock === LOCK.UNLOCK){
              var text = localStorage.username + ' unlocked this job.';
              that.addCard(STEPS.COMMENT, text, '', null, STATUSES.UNLOCKED, '', null, ''); 
              that.toggleLockJob(LOCK.UNLOCK);
              defer.resolve(body);
            }
            else{
              outputError('Fail to lock/unlock the job');
              defer.reject('Fail to lock/unlock the job');
            }
          }
          else{
            outputError('SetLock Error: ' + !!error ?  error : response.statusCode);
            defer.reject('SetLock Error: ' + !!error ?  error : response.statusCode);
          }
        });
        return defer.promise;
      },
      getLastNonComment: function(){
        if(!this.cards || this.cards.length === 0){
          return -1;
        }
        var nonComments = [STEPS.REVIEW, STEPS.PROOF, STEPS.CUSTOMERREVIEWRECEIVED, STEPS.PROOFREVIEW, STEPS.ARTREVISION];
        for(var i = this.cards.length - 1; i >= 0; i--){
          if(nonComments.indexOf(this.cards[i].stepId) > -1){
            return this.cards[i].stepId;
          }
        }
        return -1;
      },
      getLastNonComment: function(list){
        if(!list || list.length === 0){
          return null;
        }
        var nonComments = [STEPS.REVIEW, STEPS.PROOF, STEPS.CUSTOMERREVIEWRECEIVED, STEPS.PROOFREVIEW, STEPS.ARTREVISION];
        for(var i = list.length - 1; i >= 0; i--){
          if(nonComments.indexOf(list[i].stepId) > -1){
            return list[i];
          }
        }
        return null;
      },
      getLastCardOfStep: function(cardStep, list){
        if(!list || list.length === 0){
          return -1;
        }
        for(var i = list.length - 1; i >= 0; i--){
          if(list[i].stepId === cardStep){
            return i;
          }
        }
        return -1;
      },      
      isLastNonComment: function(cardStep, index, list){
        if(!list || list.length === 0){
          return false;
        }
        var nonComments = [STEPS.REVIEW, STEPS.PROOF, STEPS.CUSTOMERREVIEWRECEIVED, STEPS.PROOFREVIEW, STEPS.ARTREVISION];
        var item = null,
            idx = -1;
        for(var i = list.length - 1; i >= 0; i--){
          if(nonComments.indexOf(list[i].stepId) > -1){
            item = list[i];
            idx = i;
            break;
          }
        }
        if(item === null){
          return false;
        }
        else if(item.stepId === cardStep && idx === index){
          return true;
        }
        return false;
      },
      getNextNonComment: function(cardStep, startIdx, list){
        if(!list || list.length === 0){
          return null;
        }
        for(var i = startIdx; i < list.length; i++){
          if(list[i].stepId === cardStep){
            return list[i];
          }
        }
        return null;
      },
      showAlert: function(text){
        this.alertText = text;
        document.getElementById('alert-modal').open();
      },
      setViewers: function(list){
        if(!list || list.length === 0){
          this.viewers = [];
        }
        else{
          var array = [];
          list.forEach(function(viewer){
            if(viewer.username !== localStorage.username){
              array.push(viewer.username);              
            }
          });
          this.viewers = array;
        }
      },
      getUserName: function(id){
        for(var i = 0; i < this.users.length; i++){
          if(this.users[i].userId === id){
            return this.users[i].username;
          }
        }
        return null;
      },
      receiveFeedback: function(e){
        var that = this;
        var button = Polymer.dom(e).localTarget;
        var stepid = e.model.item.stepId;
        button.setAttribute('disabled', true);

        this.getCurrJob().then(
          function(job){
            // button.removeAttribute('disabled');
            if(job.status.toLowerCase() === STATUSESTEXT.WORKING){
              var isLast = that.isLastNonComment(stepid, e.model.item.index, job.cards);
              if(!!isLast){
                that.addCard(stepid, '', '', null, STATUSES.WORKING, e.model.item.version, false, '');
                // Polymer.dom(e).localTarget.setAttribute('disabled', true);
                button.style.display = 'none';
                button.nextElementSibling.removeAttribute('disabled');
                button.nextElementSibling.display = 'inline-block';
                button.nextElementSibling.nextElementSibling.removeAttribute('disabled');
                button.nextElementSibling.nextElementSibling.display = 'inline-block';
                button.previousElementSibling.display = 'block';
                button.previousElementSibling.previousElementSibling.display = 'block';
              }
              else{
                var reviewId = stepid === STEPS.ARTREVISION ? STEPS.REVIEW : STEPS.PROOFREVIEW;
                var item = that.getNextNonComment(reviewId, e.model.item.index, job.cards);
                if(item === null){
                  that.showAlert('This art revision/proof has already been reviewed.');
                }
                else{
                  var text = item.approve === REVIEW.REJECT ? 'rejected' : 'approved';
                  that.showAlert('This art revision/proof has already been ' + text + ' by ' + item.username);
                }                
              }              
            }
            else if(job.status.toLowerCase() === STATUSESTEXT.DONE){
              that.showAlert('This job has already been closed.');
            }
            else{
              var username = that.getUserName(job.lockerId);
              var text = '';
              if(!!username){
                text = username + ' is revising it.';
              }
              that.showAlert('This job is locked. ' + text);
            }
          }, 
          function(e){outputError(e)}
        );        
      }
    });
	</script>
</dom-module>